<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
    <title>ORM API &mdash; odoo 8.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/patchqueue.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/patchqueue.js"></script>
    <script type="text/javascript" src="../_static/jquery.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.js"></script>
    <script type="text/javascript" src="../_static/doc.js"></script>
    <script type="text/javascript" src="../_static/jquery.noconflict.js"></script>
    <link rel="top" title="odoo 8.0 documentation" href="../index.html" />
    <link rel="up" title="Reference" href="../reference.html" />
    <link rel="next" title="Data Files" href="data.html" />
    <link rel="prev" title="Reference" href="../reference.html" /> 
  </head>
  <body role="document"><header class="">
    <figure class="card top">
      <span class="card-img" style="background-image: url('../_static/banners/orm_api.jpg');"></span>
    </figure>
  </header>
  <nav id="main_navbar" class="navbar ">
    <div class="container-fluid">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".navbar-main">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <nav class="nav navbar-nav navbar-left">
          <li id="main-back"><a href="../index.html" class="mdi-navigation-arrow-back"></a></li>
          <li>
            <h1 id="main_title">ORM API</h1>
          </li>
        </nav>
      </div>

      <nav class="collapse navbar-collapse navbar-main navbar-right" role="navigation">
        
        <ul class="current navbar-nav navbar-right nav"><li class="toctree-l1 dropdown"><a data-toggle="dropdown" href="../tutorials.html" class="dropdown-toggle internal reference">Tutorials</a><ul class="dropdown-menu"><li class="toctree-l2"><a href="../howtos/themes.html" class="internal reference">Theme Tutorial</a></li><li class="toctree-l2"><a href="../howtos/website.html" class="internal reference">Building a Website</a></li><li class="toctree-l2"><a href="../howtos/backend.html" class="internal reference">Building a Module</a></li><li class="toctree-l2"><a href="../howtos/web.html" class="internal reference">Building Interface Extensions</a></li></ul></li><li class="toctree-l1"><a href="../api_integration.html" class="internal reference">Web Service API</a><ul ></ul></li><li class="toctree-l1 dropdown"><a data-toggle="dropdown" href="../setup.html" class="dropdown-toggle internal reference">Setting Up</a><ul class="dropdown-menu"><li class="toctree-l2"><a href="../setup/install.html" class="internal reference">Installing Odoo</a></li><li class="toctree-l2"><a href="../setup/deploy.html" class="internal reference">Deploying Odoo</a></li></ul></li><li class="toctree-l1 current dropdown"><a data-toggle="dropdown" href="../reference.html" class="dropdown-toggle internal reference">Reference</a><ul class="current dropdown-menu"><li class="current toctree-l2"><a href="" class="current internal reference">ORM API</a></li><li class="toctree-l2"><a href="data.html" class="internal reference">Data Files</a></li><li class="toctree-l2"><a href="actions.html" class="internal reference">Actions</a></li><li class="toctree-l2"><a href="views.html" class="internal reference">Views</a></li><li class="toctree-l2"><a href="module.html" class="internal reference">Modules</a></li><li class="toctree-l2"><a href="cmdline.html" class="internal reference">Command-line interface: odoo.py</a></li><li class="toctree-l2"><a href="security.html" class="internal reference">Security in Odoo</a></li><li class="toctree-l2"><a href="testing.html" class="internal reference">Testing Modules</a></li><li class="toctree-l2"><a href="http.html" class="internal reference">Web Controllers</a></li><li class="toctree-l2"><a href="qweb.html" class="internal reference">QWeb</a></li><li class="toctree-l2"><a href="javascript.html" class="internal reference">Javascript</a></li><li class="toctree-l2"><a href="translations.html" class="internal reference">Translating Modules</a></li><li class="toctree-l2"><a href="reports.html" class="internal reference">QWeb Reports</a></li><li class="toctree-l2"><a href="workflows.html" class="internal reference">Workflows</a></li><li class="toctree-l2"><a href="guidelines.html" class="internal reference">Odoo Guidelines</a></li><li class="toctree-l2"><a href="upgrade_api.html" class="internal reference">Upgrade API</a></li></ul></li><li class="toctree-l1 dropdown"><a data-toggle="dropdown" href="../business.html" class="dropdown-toggle internal reference">Business Mementoes</a><ul class="dropdown-menu"><li class="toctree-l2"><a href="https://odoo.com/documentation/functional/accounting.html" class="external reference">Accounting Memento (US GAAP)</a></li><li class="toctree-l2"><a href="https://odoo.com/documentation/functional/double-entry.html" class="external reference">Double-Entry Inventory</a></li><li class="toctree-l2"><a href="https://odoo.com/documentation/functional/valuation.html" class="external reference">Inventory Valuations</a></li></ul></li></ul>
      </nav>
    </div>
  </nav>
    
  
  <main class="container ">
    
    <div class="row">
      
      <aside>
        <div class="navbar-aside text-center">
          <div class="logo_box">
            <span class="logo"></span>
            Documentation
          </div>
          <ul class="list-group text-left nav"><li class="list-group-item"><a href="#recordsets" class="ripple internal reference">Recordsets</a><ul ><li class="list-group-item"><a href="#field-access" class="ripple internal reference">Field access</a></li><li class="list-group-item"><a href="#set-operations" class="ripple internal reference">Set operations</a></li><li class="list-group-item"><a href="#other-recordset-operations" class="ripple internal reference">Other recordset operations</a></li></ul></li><li class="list-group-item"><a href="#environment" class="ripple internal reference">Environment</a><ul ><li class="list-group-item"><a href="#altering-the-environment" class="ripple internal reference">Altering the environment</a></li></ul></li><li class="list-group-item"><a href="#common-orm-methods" class="ripple internal reference">Common ORM methods</a></li><li class="list-group-item"><a href="#creating-models" class="ripple internal reference">Creating Models</a><ul ><li class="list-group-item"><a href="#computed-fields" class="ripple internal reference">Computed fields</a><ul ><li class="list-group-item"><a href="#related-fields" class="ripple internal reference">Related fields</a></li></ul></li><li class="list-group-item"><a href="#onchange-updating-ui-on-the-fly" class="ripple internal reference">onchange: updating UI on the fly</a></li><li class="list-group-item"><a href="#low-level-sql" class="ripple internal reference">Low-level SQL</a></li></ul></li><li class="list-group-item"><a href="#compatibility-between-new-api-and-old-api" class="ripple internal reference">Compatibility between new API and old API</a></li><li class="list-group-item"><a href="#model-reference" class="ripple internal reference">Model Reference</a></li><li class="list-group-item"><a href="#method-decorators" class="ripple internal reference">Method decorators</a></li><li class="list-group-item"><a href="#fields" class="ripple internal reference">Fields</a><ul ><li class="list-group-item"><a href="#basic-fields" class="ripple internal reference">Basic fields</a></li><li class="list-group-item"><a href="#relational-fields" class="ripple internal reference">Relational fields</a></li></ul></li><li class="list-group-item"><a href="#inheritance-and-extension" class="ripple internal reference">Inheritance and extension</a><ul ><li class="list-group-item"><a href="#classical-inheritance" class="ripple internal reference">Classical inheritance</a></li><li class="list-group-item"><a href="#extension" class="ripple internal reference">Extension</a></li><li class="list-group-item"><a href="#delegation" class="ripple internal reference">Delegation</a></li></ul></li><li class="list-group-item"><a href="#domains" class="ripple internal reference">Domains</a></li><li class="list-group-item"><a href="#porting-from-the-old-api-to-the-new-api" class="ripple internal reference">Porting from the old API to the new API</a><ul ><li class="list-group-item"><a href="#automatic-bridging-of-old-api-methods" class="ripple internal reference">Automatic bridging of old API methods</a></li></ul></li></ul>
          
          <p class="gith-container"><a href="https://github.com/odoo/odoo/edit/8.0/doc/reference/orm.rst" class="gith-link">
              Edit on GitHub
          </a></p>
          
        </div>
      </aside>
      
      <article class="doc-body ">
        
        
  <section id="orm-api"><i id="reference-orm"></i></section><section id="recordsets"><h2 >Recordsets</h2><div class="versionadded"><p ><span class="versionmodified">New in version 8.0: </span>This page documents the New API added in Odoo 8.0 which should be the
primary development API going forward. It also provides information about
porting from or bridging with the &quot;old API&quot; of versions 7 and earlier, but
does not explicitly document that API. See the old documentation for that.</p></div><p >Interaction with models and records is performed through recordsets, a sorted
set of records of the same model.</p><div role="alert" class="alert-warning alert"><p class="alert-title">Warning</p><p >contrary to what the name implies, it is currently possible for
recordsets to contain duplicates. This may change in the future.</p></div><p >Methods defined on a model are executed on a recordset, and their <code >self</code> is
a recordset:</p><div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">AModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s">&#39;a.model&#39;</span>
    <span class="k">def</span> <span class="nf">a_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># self can be anywhere between 0 records and all records in the</span>
        <span class="c"># database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_operation</span><span class="p">()</span>
</pre></div>
</div>
<p >Iterating on a recordset will yield new sets of <em >a single record</em>
(&quot;singletons&quot;), much like iterating on a Python string yields strings of a
single characters:</p><div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">do_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span> <span class="bp">self</span> <span class="c"># =&gt; a.model(1, 2, 3, 4, 5)</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">record</span> <span class="c"># =&gt; a.model(1), then a.model(2), then a.model(3), ...</span>
</pre></div>
</div>
</section><section id="field-access"><h3 >Field access</h3><p >Recordsets provide an &quot;Active Record&quot; interface: model fields can be read and
written directly from the record, but only on singletons (single-record
recordsets). Setting a field's value triggers an update to the database:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">name</span>
<span class="go">Example Name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">company_id</span><span class="o">.</span><span class="n">name</span>
<span class="go">Company Name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">record</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Bob&quot;</span>
</pre></div>
</div>
<p >Trying to read or write a field on multiple records will raise an error.</p><p >Accessing a relational field (<code class="py xref py-class">Many2one</code>,
<code class="py xref py-class">One2many</code>, <code class="py xref py-class">Many2many</code>)
<em >always</em> returns a recordset, empty if the field is not set.</p><div role="alert" class="alert-danger alert"><p class="alert-title">Danger</p><p >each assignment to a field triggers a database update, when setting
multiple fields at the same time or setting fields on multiple records
(to the same value), use <code class="py py-meth xref">write()</code>:</p><div class="highlight-python"><div class="highlight"><pre><span class="c"># 3 * len(records) database updates</span>
<span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
    <span class="n">record</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">record</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">record</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c"># len(records) database updates</span>
<span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
    <span class="n">record</span><span class="o">.</span><span class="n">write</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>

<span class="c"># 1 database update</span>
<span class="n">records</span><span class="o">.</span><span class="n">write</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
</pre></div>
</div>
</div></section><section id="set-operations"><h3 >Set operations</h3><p >Recordsets are immutable, but sets of the same model can be combined using
various set operations, returning new recordsets. Set operations do <em >not</em>
preserve order.</p><ul ><li ><code >record in set</code> returns whether <code >record</code> (which must be a 1-element
recordset) is present in <code >set</code>. <code >record not in set</code> is the inverse
operation</li><li ><code >set1 | set2</code> returns the union of the two recordsets, a new recordset
containing all records present in either source</li><li ><code >set1 &amp; set2</code> returns the intersection of two recordsets, a new recordset
containing only records present in both sources</li><li ><code >set1 - set2</code> returns a new recordset containing only records of <code >set1</code>
which are <em >not</em> in <code >set2</code></li></ul></section><section id="other-recordset-operations"><h3 >Other recordset operations</h3><p >Recordsets are iterable so the usual Python tools are available for
transformation (<a href="https://docs.python.org/2/library/functions.html#map" class="external reference" title="(in Python v2.7)"><code >map()</code></a>, <a href="https://docs.python.org/2/library/functions.html#sorted" class="external reference" title="(in Python v2.7)"><code >sorted()</code></a>,
<a href="https://docs.python.org/2/library/itertools.html#itertools.ifilter" class="external reference" title="(in Python v2.7)"><code class="py xref py-func">ifilter()</code></a>, ...) however these return either a
<a href="https://docs.python.org/2/library/functions.html#list" class="external reference" title="(in Python v2.7)"><code >list</code></a> or an <a href="https://docs.python.org/2/glossary.html#term-iterator" class="external reference" title="(in Python v2.7)"><span >iterator</span></a>, removing the ability to
call methods on their result, or to use set operations.</p><p >Recordsets therefore provide these operations returning recordsets themselves
(when possible):</p><dl ><dt ><code class="py py-meth xref">filtered()</code></dt><dd ><p >returns a recordset containing only records satisfying the provided
predicate function. The predicate can also be a string to filter by a
field being true or false:</p><div class="highlight-python"><div class="highlight"><pre><span class="c"># only keep records whose company is the current user&#39;s</span>
<span class="n">records</span><span class="o">.</span><span class="n">filtered</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">company_id</span> <span class="o">==</span> <span class="n">user</span><span class="o">.</span><span class="n">company_id</span><span class="p">)</span>

<span class="c"># only keep records whose partner is a company</span>
<span class="n">records</span><span class="o">.</span><span class="n">filtered</span><span class="p">(</span><span class="s">&quot;partner_id.is_company&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">sorted()</code></dt><dd ><p >returns a recordset sorted by the provided key function. If no key
is provided, use the model's default sort order:</p><div class="highlight-python"><div class="highlight"><pre><span class="c"># sort records by name</span>
<span class="n">records</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">mapped()</code></dt><dd ><p >applies the provided function to each record in the recordset, returns
a recordset if the results are recordsets:</p><div class="highlight-python"><div class="highlight"><pre><span class="c"># returns a list of summing two fields for each record in the set</span>
<span class="n">records</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">field1</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">field2</span><span class="p">)</span>
</pre></div>
</div>
<p >The provided function can be a string to get field values:</p><div class="highlight-python"><div class="highlight"><pre><span class="c"># returns a list of names</span>
<span class="n">records</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>

<span class="c"># returns a recordset of partners</span>
<span class="n">record</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="s">&#39;partner_id&#39;</span><span class="p">)</span>

<span class="c"># returns the union of all partner banks, with duplicates removed</span>
<span class="n">record</span><span class="o">.</span><span class="n">mapped</span><span class="p">(</span><span class="s">&#39;partner_id.bank_ids&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl></section><section id="environment"><h2 >Environment</h2><p >The <code class="py xref py-class">Environment</code> stores various contextual data used by
the ORM: the database cursor (for database queries), the current user
(for access rights checking) and the current context (storing arbitrary
metadata). The environment also stores caches.</p><p >All recordsets have an environment, which is immutable, can be accessed
using <code class="py xref py-attr">env</code> and gives access to the current user
(<code class="py xref py-attr">user</code>), the cursor
(<code class="py xref py-attr">cr</code>) or the context
(<code class="py xref py-attr">context</code>):</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="o">.</span><span class="n">env</span>
<span class="go">&lt;Environment object ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">user</span>
<span class="go">res.user(3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">records</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cr</span>
<span class="go">&lt;Cursor object ...)</span>
</pre></div>
</div>
<p >When creating a recordset from an other recordset, the environment is
inherited. The environment can be used to get an empty recordset in an
other model, and query that model:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="s">&#39;res.partner&#39;</span><span class="p">]</span>
<span class="go">res.partner</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="s">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">search</span><span class="p">([[</span><span class="s">&#39;is_company&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;customer&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">]])</span>
<span class="go">res.partner(7, 18, 12, 14, 17, 19, 8, 31, 26, 16, 13, 20, 30, 22, 29, 15, 23, 28, 74)</span>
</pre></div>
</div>
</section><section id="altering-the-environment"><h3 >Altering the environment</h3><p >The environment can be customized from a recordset. This returns a new
version of the recordset using the altered environment.</p><dl ><dt ><code class="py py-meth xref">sudo()</code></dt><dd ><p >creates a new environment with the provided user set, uses the
administrator if none is provided (to bypass access rights/rules in safe
contexts), returns a copy of the recordset it is called on using the
new environment:</p><div class="highlight-python"><div class="highlight"><pre><span class="c"># create partner object as administrator</span>
<span class="n">env</span><span class="p">[</span><span class="s">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sudo</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&quot;A Partner&quot;</span><span class="p">})</span>

<span class="c"># list partners visible by the &quot;public&quot; user</span>
<span class="n">public</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="s">&#39;base.public_user&#39;</span><span class="p">)</span>
<span class="n">env</span><span class="p">[</span><span class="s">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sudo</span><span class="p">(</span><span class="n">public</span><span class="p">)</span><span class="o">.</span><span class="n">search</span><span class="p">([])</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">with_context()</code></dt><dd ><ol ><li >can take a single positional parameter, which replaces the current
environment's context</li><li >can take any number of parameters by keyword, which are added to either
the current environment's context or the context set during step 1</li></ol><div class="highlight-python"><div class="highlight"><pre><span class="c"># look for partner, or create one with specified timezone if none is</span>
<span class="c"># found</span>
<span class="n">env</span><span class="p">[</span><span class="s">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">with_context</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">a_tz</span><span class="p">)</span><span class="o">.</span><span class="n">find_or_create</span><span class="p">(</span><span class="n">email_address</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">with_env()</code></dt><dd >replaces the existing environment entirely</dd></dl></section><section id="common-orm-methods"><h2 >Common ORM methods</h2><dl ><dt ><code class="py py-meth xref">search()</code></dt><dd ><p >Takes a <a href="#reference-orm-domains" class="internal reference"><span >search domain</span></a>, returns a recordset
of matching records. Can return a subset of matching records (<code >offset</code>
and <code >limit</code> parameters) and be ordered (<code >order</code> parameter):</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># searches the current model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">([(</span><span class="s">&#39;is_company&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;customer&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)])</span>
<span class="go">res.partner(7, 18, 12, 14, 17, 19, 8, 31, 26, 16, 13, 20, 30, 22, 29, 15, 23, 28, 74)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">([(</span><span class="s">&#39;is_company&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)],</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;Agrolait&#39;</span>
</pre></div>
</div>
<div role="alert" class="alert-info alert"><p class="alert-title">Tip</p><p >to just check if any record matches a domain, or count the number
of records which do, use
<code class="py py-meth xref">search_count()</code></p></div></dd><dt ><code class="py py-meth xref">create()</code></dt><dd ><p >Takes a number of field values, and returns a recordset containing the
record created:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&quot;New Name&quot;</span><span class="p">})</span>
<span class="go">res.partner(78)</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">write()</code></dt><dd ><p >Takes a number of field values, writes them to all the records in its
recordset. Does not return anything:</p><div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">({</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&quot;Newer Name&quot;</span><span class="p">})</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">browse()</code></dt><dd ><p >Takes a database id or a list of ids and returns a recordset, useful when
record ids are obtained from outside Odoo (e.g. round-trip through
external system) or <a href="#reference-orm-oldapi" class="internal reference"><span >when calling methods in the old API</span></a>:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">browse</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="go">res.partner(7, 18, 12)</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">exists()</code></dt><dd ><p >Returns a new recordset containing only the records which exist in the
database. Can be used to check whether a record (e.g. obtained externally)
still exists:</p><div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="ow">not</span> <span class="n">record</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The record has been deleted&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >or after calling a method which could have removed some records:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">records</span><span class="o">.</span><span class="n">may_remove_some</span><span class="p">()</span>
<span class="c"># only keep records which were not deleted</span>
<span class="n">records</span> <span class="o">=</span> <span class="n">records</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">ref()</code></dt><dd ><p >Environment method returning the record matching a provided
<a href="../glossary.html#term-external-id" class="internal reference"><span class="std std-term xref">external id</span></a>:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="s">&#39;base.group_public&#39;</span><span class="p">)</span>
<span class="go">res.groups(2)</span>
</pre></div>
</div>
</dd><dt ><code class="py py-meth xref">ensure_one()</code></dt><dd ><p >checks that the recordset is a singleton (only contains a single record),
raises an error otherwise:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">records</span><span class="o">.</span><span class="n">ensure_one</span><span class="p">()</span>
<span class="c"># is equivalent to but clearer than:</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">records</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expected singleton&quot;</span>
</pre></div>
</div>
</dd></dl></section><section id="creating-models"><h2 >Creating Models</h2><p >Model fields are defined as attributes on the model itself:</p><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openerp</span> <span class="kn">import</span> <span class="n">models</span><span class="p">,</span> <span class="n">fields</span>
<span class="k">class</span> <span class="nc">AModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s">&#39;a.model.name&#39;</span>

    <span class="n">field1</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">()</span>
</pre></div>
</div>
<div role="alert" class="alert-warning alert"><p class="alert-title">Warning</p><p >this means you can not define a field and a method with the same
name, they will conflict</p></div><p >By default, the field's label (user-visible name) is a capitalized version of
the field name, this can be overridden with the <code >string</code> parameter:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">field2</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s">&quot;an other field&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >For the various field types and parameters, see <a href="#reference-orm-fields" class="internal reference"><span >the fields reference</span></a>.</p><p >Default values are defined as parameters on fields, either a value:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">a_field</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s">&quot;a value&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >or a function called to compute the default value, which should return that
value:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">a_field</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">compute_default_value</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">compute_default_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">()</span>
</pre></div>
</div>
</section><section id="computed-fields"><h3 >Computed fields</h3><p >Fields can be computed (instead of read straight from the database) using the
<code >compute</code> parameter. <strong >It must assign the computed value to the field</strong>. If
it uses the values of other <em >fields</em>, it should specify those fields using
<code class="py xref py-func">depends()</code>:</p><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">openerp</span> <span class="kn">import</span> <span class="n">api</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s">&#39;_compute_total&#39;</span><span class="p">)</span>

<span class="nd">@api.depends</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">,</span> <span class="s">&#39;tax&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_compute_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">record</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">record</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">record</span><span class="o">.</span><span class="n">tax</span>
</pre></div>
</div>
<ul ><li ><p >dependencies can be dotted paths when using sub-fields:</p><div class="highlight-python"><div class="highlight"><pre><span class="nd">@api.depends</span><span class="p">(</span><span class="s">&#39;line_ids.value&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_compute_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">record</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">line_ids</span><span class="p">)</span>
</pre></div>
</div>
</li><li >computed fields are not stored by default, they are computed and
returned when requested. Setting <code >store=True</code> will store them in the
database and automatically enable searching</li><li ><p >searching on a computed field can also be enabled by setting the <code >search</code>
parameter. The value is a method name returning a
<a href="#reference-orm-domains" class="internal reference"><span >Domains</span></a>:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">upper_name</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s">&#39;_compute_upper&#39;</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="s">&#39;_search_upper&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_search_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s">&#39;like&#39;</span><span class="p">:</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="s">&#39;ilike&#39;</span>
    <span class="k">return</span> <span class="p">[(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
</pre></div>
</div>
</li><li ><p >to allow <em >setting</em> values on a computed field, use the <code >inverse</code>
parameter. It is the name of a function reversing the computation and
setting the relevant fields:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">document</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s">&#39;_get_document&#39;</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="s">&#39;_set_document&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_document</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">get_document_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">record</span><span class="o">.</span><span class="n">document</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_set_document</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">record</span><span class="o">.</span><span class="n">document</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">get_document_path</span><span class="p">())</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">document</span><span class="p">)</span>
</pre></div>
</div>
</li><li ><p >multiple fields can be computed at the same time by the same method, just
use the same method on all fields and set all of them:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">discount_value</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s">&#39;_apply_discount&#39;</span><span class="p">)</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">compute</span><span class="o">=</span><span class="s">&#39;_apply_discount&#39;</span><span class="p">)</span>

<span class="nd">@depends</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">,</span> <span class="s">&#39;discount&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_apply_discount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="c"># compute actual discount from discount percentage</span>
        <span class="n">discount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">discount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discount_value</span> <span class="o">=</span> <span class="n">discount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">discount</span>
</pre></div>
</div>
</li></ul></section><section id="related-fields"><h4 >Related fields</h4><p >A special case of computed fields are <em >related</em> (proxy) fields, which provide
the value of a sub-field on the current record. They are defined by setting
the <code >related</code> parameter and like regular computed fields they can be
stored:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">nickname</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">related</span><span class="o">=</span><span class="s">&#39;user_id.partner_id.name&#39;</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</section><section id="onchange-updating-ui-on-the-fly"><h3 >onchange: updating UI on the fly</h3><p >When a user changes a field's value in a form (but hasn't saved the form yet),
it can be useful to automatically update other fields based on that value
e.g. updating a final total when the tax is changed or a new invoice line is
added.</p><ul ><li >computed fields are automatically checked and recomputed, they do not need
an <code >onchange</code></li><li ><p >for non-computed fields, the <code class="py xref py-func">onchange()</code> decorator is used
to provide new field values:</p><div class="highlight-python"><div class="highlight"><pre><span class="nd">@api.onchange</span><span class="p">(</span><span class="s">&#39;field1&#39;</span><span class="p">,</span> <span class="s">&#39;field2&#39;</span><span class="p">)</span> <span class="c"># if these fields are changed, call method</span>
<span class="k">def</span> <span class="nf">check_change</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">field1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">field2</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field3</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p >the changes performed during the method are then sent to the client program
and become visible to the user</p></li><li >Both computed fields and new-API onchanges are automatically called by the
client without having to add them in views</li><li ><p >It is possible to suppress the trigger from a specific field by adding
<code >on_change=&quot;0&quot;</code> in a view:</p><div class="highlight-python"><div class="highlight"><pre>&lt;field name=&quot;name&quot; on_change=&quot;0&quot;/&gt;
</pre></div>
</div>
<p >will not trigger any interface update when the field is edited by the user,
even if there are function fields or explicit onchange depending on that
field.</p></li></ul><div role="alert" class="alert-info alert"><p class="alert-title">Note</p><p ><code >onchange</code> methods work on virtual records assignment on these records
is not written to the database, just used to know which value to send back
to the client</p></div></section><section id="low-level-sql"><h3 >Low-level SQL</h3><p >The <code class="py xref py-attr">cr</code> attribute on environments is the
cursor for the current database transaction and allows executing SQL directly,
either for queries which are difficult to express using the ORM (e.g. complex
joins) or for performance reasons:</p><div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">cr</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;some_sql&quot;</span><span class="p">,</span> <span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="n">param3</span><span class="p">)</span>
</pre></div>
</div>
<p >Because models use the same cursor and the <code class="py xref py-class">Environment</code>
holds various caches, these caches must be invalidated when <em >altering</em> the
database in raw SQL, or further uses of models may become incoherent. It is
necessary to clear caches when using <code >CREATE</code>, <code >UPDATE</code> or <code >DELETE</code> in
SQL, but not <code >SELECT</code> (which simply reads the database).</p><p >Clearing caches can be performed using the
<code class="py py-meth xref">invalidate_all()</code> method of the
<code class="py xref py-class">Environment</code> object.</p></section><section id="compatibility-between-new-api-and-old-api"><i id="reference-orm-oldapi"></i><h2 >Compatibility between new API and old API</h2><p >Odoo is currently transitioning from an older (less regular) API, it can be
necessary to manually bridge from one to the other manually:</p><ul ><li >RPC layers (both XML-RPC and JSON-RPC) are expressed in terms of the old
API, methods expressed purely in the new API are not available over RPC</li><li >overridable methods may be called from older pieces of code still written
in the old API style</li></ul><p >The big differences between the old and new APIs are:</p><ul ><li >values of the <code class="py xref py-class">Environment</code> (cursor, user id and
context) are passed explicitly to methods instead</li><li >record data (<code class="py xref py-attr">ids</code>) are passed explicitly to
methods, and possibly not passed at all</li><li >methods tend to work on lists of ids instead of recordsets</li></ul><p >By default, methods are assumed to use the new API style and are not callable
from the old API style.</p><div role="alert" class="alert-info aphorism alert"><p class="alert-title">Tip</p><p >calls from the new API to the old API are bridged</p><p >when using the new API style, calls to methods defined using the old API
are automatically converted on-the-fly, there should be no need to do
anything special:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># method in the old API style</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">old_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="n">ids</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c"># method in the new API style</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c"># system automatically infers how to call the old-style</span>
<span class="gp">... </span>    <span class="c"># method from the new-style method</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="o">.</span><span class="n">old_method</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span><span class="p">[</span><span class="n">model</span><span class="p">]</span><span class="o">.</span><span class="n">browse</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">new_method</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
</div><p >Two decorators can expose a new-style method to the old API:</p><dl ><dt ><code class="py xref py-func">model()</code></dt><dd ><p >the method is exposed as not using ids, its recordset will generally be
empty. Its &quot;old API&quot; signature is <code >cr, uid, *arguments, context</code>:</p><div class="highlight-python"><div class="highlight"><pre><span class="nd">@api.model</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_value</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="c"># can be called as</span>
<span class="n">old_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">a_value</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</dd><dt ><code class="py xref py-func">multi()</code></dt><dd ><p >the method is exposed as taking a list of ids (possibly empty), its
&quot;old API&quot; signature is <code >cr, uid, ids, *arguments, context</code>:</p><div class="highlight-python"><div class="highlight"><pre><span class="nd">@api.multi</span>
<span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_value</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="c"># can be called as</span>
<span class="n">old_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="p">[</span><span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">],</span> <span class="n">a_value</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl><p >Because new-style APIs tend to return recordsets and old-style APIs tend to
return lists of ids, there is also a decorator managing this:</p><dl ><dt ><code class="py xref py-func">returns()</code></dt><dd ><p >the function is assumed to return a recordset, the first parameter should
be the name of the recordset's model or <code >self</code> (for the current model).</p><p >No effect if the method is called in new API style, but transforms the
recordset into a list of ids when called from the old API style:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@api.multi</span>
<span class="gp">... </span><span class="nd">@api.returns</span><span class="p">(</span><span class="s">&#39;self&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">some_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="bp">self</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_style_model</span> <span class="o">=</span> <span class="n">env</span><span class="p">[</span><span class="s">&#39;a.model&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">()</span>
<span class="go">a.model(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_style_model</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[</span><span class="s">&#39;a.model&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_style_model</span><span class="o">.</span><span class="n">some_method</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
</dd></dl></section><section id="model-reference"><i id="reference-orm-model"></i><h2 >Model Reference</h2></section><section id="method-decorators"><i id="reference-orm-decorators"></i><h2 >Method decorators</h2></section><section id="fields"><i id="reference-orm-fields"></i><h2 >Fields</h2></section><section id="basic-fields"><i id="reference-orm-fields-basic"></i><h3 >Basic fields</h3></section><section id="relational-fields"><i id="reference-orm-fields-relational"></i><h3 >Relational fields</h3></section><section id="inheritance-and-extension"><i id="reference-orm-inheritance"></i><h2 >Inheritance and extension</h2><p >Odoo provides three different mechanisms to extend models in a modular way:</p><ul ><li >creating a new model from an existing one, adding new information to the
copy but leaving the original module as-is</li><li >extending models defined in other modules in-place, replacing the previous
version</li><li >delegating some of the model's fields to records it contains</li></ul><img src="../_images/inheritance_methods1.png" class="img-responsive center-block"></section><section id="classical-inheritance"><h3 >Classical inheritance</h3><p >When using the <code class="py xref py-attr">_inherit</code> and
<code class="py xref py-attr">_name</code> attributes together, Odoo creates a new
model using the existing one (provided via
<code class="py xref py-attr">_inherit</code>) as a base. The new model gets all the
fields, methods and meta-information (defaults &amp; al) from its base.</p><p >and using them:</p><p >will yield:</p><p >the second model has inherited from the first model's <code >check</code> method and its
<code >name</code> field, but overridden the <code >call</code> method, as when using standard
<a href="https://docs.python.org/2/tutorial/classes.html#tut-inheritance" class="external reference" title="(in Python v2.7)"><span class="std xref std-ref">Python inheritance</span></a>.</p></section><section id="extension"><h3 >Extension</h3><p >When using <code class="py xref py-attr">_inherit</code> but leaving out
<code class="py xref py-attr">_name</code>, the new model replaces the existing one,
essentially extending it in-place. This is useful to add new fields or methods
to existing models (created in other modules), or to customize or reconfigure
them (e.g. to change their default sort order):</p><p >will yield:</p><div role="alert" class="alert-info alert"><p class="alert-title">Note</p><p >it will also yield the various <span class="std xref std-ref">automatic fields</span> unless they've been disabled</p></div></section><section id="delegation"><h3 >Delegation</h3><p >The third inheritance mechanism provides more flexibility (it can be altered
at runtime) but less power: using the <code class="py xref py-attr">_inherits</code>
a model <em >delegates</em> the lookup of any field not found on the current model
to &quot;children&quot; models. The delegation is performed via
<code class="py xref py-class">Reference</code> fields automatically set up on the parent
model:</p><p >will result in:</p><p >and it's possible to write directly on the delegated field:</p><div role="alert" class="alert-warning alert"><p class="alert-title">Warning</p><p >when using delegation inheritance, methods are <em >not</em> inherited,
only fields</p></div></section><section id="domains"><i id="reference-orm-domains"></i><h2 >Domains</h2><p >A domain is a list of criteria, each criterion being a triple (either a
<code >list</code> or a <code >tuple</code>) of <code >(field_name, operator, value)</code> where:</p><dl ><dt ><code >field_name</code> (<code >str</code>)</dt><dd >a field name of the current model, or a relationship traversal through
a <code class="py xref py-class">Many2one</code> using dot-notation e.g. <code >'street'</code>
or <code >'partner_id.country'</code></dd><dt ><code >operator</code> (<code >str</code>)</dt><dd ><p >an operator used to compare the <code >field_name</code> with the <code >value</code>. Valid
operators are:</p><dl ><dt ><code >=</code></dt><dd >equals to</dd><dt ><code >!=</code></dt><dd >not equals to</dd><dt ><code >&gt;</code></dt><dd >greater than</dd><dt ><code >&gt;=</code></dt><dd >greater than or equal to</dd><dt ><code >&lt;</code></dt><dd >less than</dd><dt ><code >&lt;=</code></dt><dd >less than or equal to</dd><dt ><code >=?</code></dt><dd >unset or equals to (returns true if <code >value</code> is either <code >None</code> or
<code >False</code>, otherwise behaves like <code >=</code>)</dd><dt ><code >=like</code></dt><dd >matches <code >field_name</code> against the <code >value</code> pattern. An underscore
<code >_</code> in the pattern stands for (matches) any single character; a
percent sign <code >%</code> matches any string of zero or more characters.</dd><dt ><code >like</code></dt><dd >matches <code >field_name</code> against the <code >%value%</code> pattern. Similar to
<code >=like</code> but wraps <code >value</code> with '%' before matching</dd><dt ><code >not like</code></dt><dd >doesn't match against the <code >%value%</code> pattern</dd><dt ><code >ilike</code></dt><dd >case insensitive <code >like</code></dd><dt ><code >not ilike</code></dt><dd >case insensitive <code >not like</code></dd><dt ><code >=ilike</code></dt><dd >case insensitive <code >=like</code></dd><dt ><code >in</code></dt><dd >is equal to any of the items from <code >value</code>, <code >value</code> should be a
list of items</dd><dt ><code >not in</code></dt><dd >is unequal to all of the items from <code >value</code></dd><dt ><code >child_of</code></dt><dd ><p >is a child (descendant) of a <code >value</code> record.</p><p >Takes the semantics of the model into account (i.e following the
relationship field named by
<code class="py xref py-attr">_parent_name</code>).</p></dd></dl></dd><dt ><code >value</code></dt><dd >variable type, must be comparable (through <code >operator</code>) to the named
field</dd></dl><p >Domain criteria can be combined using logical operators in <em >prefix</em> form:</p><dl ><dt ><code >'&amp;'</code></dt><dd >logical <em >AND</em>, default operation to combine criteria following one
another. Arity 2 (uses the next 2 criteria or combinations).</dd><dt ><code >'|'</code></dt><dd >logical <em >OR</em>, arity 2.</dd><dt ><code >'!'</code></dt><dd ><p >logical <em >NOT</em>, arity 1.</p><div role="alert" class="alert-info aphorism alert"><p class="alert-title">Tip</p><p >Mostly to negate combinations of criteria</p><p >Individual criterion generally have a negative form (e.g. <code >=</code> -&gt;
<code >!=</code>, <code >&lt;</code> -&gt; <code >&gt;=</code>) which is simpler than negating the positive.</p></div></dd></dl><div role="alert" class="admonition-example alert"><p class="alert-title">Example</p><p >To search for partners named <em >ABC</em>, from belgium or germany, whose language
is not english:</p><div class="highlight-python"><div class="highlight"><pre><span class="p">[(</span><span class="s">&#39;name&#39;</span><span class="p">,</span><span class="s">&#39;=&#39;</span><span class="p">,</span><span class="s">&#39;ABC&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s">&#39;language.code&#39;</span><span class="p">,</span><span class="s">&#39;!=&#39;</span><span class="p">,</span><span class="s">&#39;en_US&#39;</span><span class="p">),</span>
 <span class="s">&#39;|&#39;</span><span class="p">,(</span><span class="s">&#39;country_id.code&#39;</span><span class="p">,</span><span class="s">&#39;=&#39;</span><span class="p">,</span><span class="s">&#39;be&#39;</span><span class="p">),</span>
     <span class="p">(</span><span class="s">&#39;country_id.code&#39;</span><span class="p">,</span><span class="s">&#39;=&#39;</span><span class="p">,</span><span class="s">&#39;de&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p >This domain is interpreted as:</p><div class="highlight-text"><div class="highlight"><pre>    (name is &#39;ABC&#39;)
AND (language is NOT english)
AND (country is Belgium OR Germany)
</pre></div>
</div>
</div></section><section id="porting-from-the-old-api-to-the-new-api"><h2 >Porting from the old API to the new API</h2><ul ><li >bare lists of ids are to be avoided in the new API, use recordsets instead</li><li >methods still written in the old API should be automatically bridged by the
ORM, no need to switch to the old API, just call them as if they were a new
API method. See <a href="#reference-orm-oldapi-bridging" class="internal reference"><span >Automatic bridging of old API methods</span></a> for more details.</li><li ><code class="py py-meth xref">search()</code> returns a recordset, no point in e.g.
browsing its result</li><li ><code >fields.related</code> and <code >fields.function</code> are replaced by using a normal
field type with either a <code >related=</code> or a <code >compute=</code> parameter</li><li ><code class="py xref py-func">depends()</code> on <code >compute=</code> methods <strong >must be complete</strong>,
it must list <strong >all</strong> the fields and sub-fields which the compute method
uses. It is better to have too many dependencies (will recompute the field
in cases where that is not needed) than not enough (will forget to recompute
the field and then values will be incorrect)</li><li ><strong >remove</strong> all <code >onchange</code> methods on computed fields. Computed fields are
automatically re-computed when one of their dependencies is changed, and
that is used to auto-generate <code >onchange</code> by the client</li><li >the decorators <code class="py xref py-func">model()</code> and <code class="py xref py-func">multi()</code> are
for bridging <em >when calling from the old API context</em>, for internal or pure
new-api (e.g. compute) they are useless</li><li >remove <code class="py xref py-attr">_default</code>, replace by <code >default=</code>
parameter on corresponding fields</li><li ><p >if a field's <code >string=</code> is the titlecased version of the field name:</p><div class="highlight-python"><div class="highlight"><pre><span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">Char</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="s">&quot;Name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p >it is useless and should be removed</p></li><li >the <code >multi=</code> parameter does not do anything on new API fields use the same
<code >compute=</code> methods on all relevant fields for the same result</li><li >provide <code >compute=</code>, <code >inverse=</code> and <code >search=</code> methods by name (as a
string), this makes them overridable (removes the need for an intermediate
&quot;trampoline&quot; function)</li><li >double check that all fields and methods have different names, there is no
warning in case of collision (because Python handles it before Odoo sees
anything)</li><li >the normal new-api import is <code >from openerp import fields, models</code>. If
compatibility decorators are necessary, use <code >from openerp import api,
fields, models</code></li><li >avoid the <code class="py xref py-func">one()</code> decorator, it probably does not do what
you expect</li><li >remove explicit definition of <code class="py xref py-attr">create_uid</code>,
<code class="py xref py-attr">create_date</code>,
<code class="py xref py-attr">write_uid</code> and
<code class="py xref py-attr">write_date</code> fields: they are now created as
regular &quot;legitimate&quot; fields, and can be read and written like any other
field out-of-the-box</li><li ><p >when straight conversion is impossible (semantics can not be bridged) or the
&quot;old API&quot; version is not desirable and could be improved for the new API, it
is possible to use completely different &quot;old API&quot; and &quot;new API&quot;
implementations for the same method name using <code class="py xref py-func">v7()</code> and
<code class="py xref py-func">v8()</code>. The method should first be defined using the
old-API style and decorated with <code class="py xref py-func">v7()</code>, it should then be
re-defined using the exact same name but the new-API style and decorated
with <code class="py xref py-func">v8()</code>. Calls from an old-API context will be
dispatched to the first implementation and calls from a new-API context will
be dispatched to the second implementation. One implementation can call (and
frequently does) call the other by switching context.</p><div role="alert" class="alert-danger alert"><p class="alert-title">Danger</p><p >using these decorators makes methods extremely difficult to
override and harder to understand and document</p></div></li><li ><p >uses of <code class="py xref py-attr">_columns</code> or
<code class="py xref py-attr">_all_columns</code> should be replaced by
<code class="py xref py-attr">_fields</code>, which provides access to instances of
new-style <code class="py xref py-class">openerp.fields.Field</code> instances (rather than old-style
<code class="py xref py-class">openerp.osv.fields._column</code>).</p><p >Non-stored computed fields created using the new API style are <em >not</em>
available in <code class="py xref py-attr">_columns</code> and can only be
inspected through <code class="py xref py-attr">_fields</code></p></li><li >reassigning <code >self</code> in a method is probably unnecessary and may break
translation introspection</li><li ><p ><code class="py xref py-class">Environment</code> objects rely on some threadlocal state,
which has to be set up before using them. It is necessary to do so using the
<code class="py py-meth xref">openerp.api.Environment.manage()</code> context manager when trying to use
the new API in contexts where it hasn't been set up yet, such as new threads
or a Python interactive environment:</p><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">openerp</span> <span class="kn">import</span> <span class="n">api</span><span class="p">,</span> <span class="n">modules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">modules</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">RegistryManager</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;test&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cr</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">env</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">Environment</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{})</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">environments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">api</span><span class="o">.</span><span class="n">Environment</span><span class="o">.</span><span class="n">manage</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">env</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">Environment</span><span class="p">(</span><span class="n">cr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{})</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">env</span><span class="p">[</span><span class="s">&#39;res.partner&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">browse</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">res.partner(1,)</span>
</pre></div>
</div>
</li></ul></section><section id="automatic-bridging-of-old-api-methods"><i id="reference-orm-oldapi-bridging"></i><h3 >Automatic bridging of old API methods</h3><p >When models are initialized, all methods are automatically scanned and bridged
if they look like models declared in the old API style. This bridging makes
them transparently callable from new-API-style methods.</p><p >Methods are matched as &quot;old-API style&quot; if their second positional parameter
(after <code >self</code>) is called either <code >cr</code> or <code >cursor</code>. The system also
recognizes the third positional parameter being called <code >uid</code> or <code >user</code> and
the fourth being called <code >id</code> or <code >ids</code>. It also recognizes the presence of
any parameter called <code >context</code>.</p><p >When calling such methods from a new API context, the system will
automatically fill matched parameters from the current
<code class="py xref py-class">Environment</code> (for <code class="py xref py-attr">cr</code>,
<code class="py xref py-attr">user</code> and
<code class="py xref py-attr">context</code>) or the current recordset (for <code >id</code>
and <code >ids</code>).</p><p >In the rare cases where it is necessary, the bridging can be customized by
decorating the old-style method:</p><ul ><li >disabling it entirely, by decorating a method with
<code class="py xref py-func">noguess()</code> there will be no bridging and methods will be
called the exact same way from the new and old API styles</li><li ><p >defining the bridge explicitly, this is mostly for methods which are matched
incorrectly (because parameters are named in unexpected ways):</p><dl ><dt ><code class="py xref py-func">cr()</code></dt><dd >will automatically prepend the current cursor to explicitly provided
parameters, positionally</dd><dt ><code class="py xref py-func">cr_uid()</code></dt><dd >will automatically prepend the current cursor and user's id to explictly
provided parameters</dd><dt ><code class="py xref py-func">cr_uid_ids()</code></dt><dd >will automatically prepend the current cursor, user's id and recordset's
ids to explicitly provided parameters</dd><dt ><code class="py xref py-func">cr_uid_id()</code></dt><dd ><p >will loop over the current recordset and call the method once for each
record, prepending the current cursor, user's id and record's id to
explicitly provided parameters.</p><div role="alert" class="alert-danger alert"><p class="alert-title">Danger</p><p >the result of this wrapper is <em >always a list</em> when calling
from a new-API context</p></div></dd></dl><p >All of these methods have a <code >_context</code>-suffixed version
(e.g. <code class="py xref py-func">cr_uid_context()</code>) which also passes the current
context <em >by keyword</em>.</p></li><li >dual implementations using <code class="py xref py-func">v7()</code> and
<code class="py xref py-func">v8()</code> will be ignored as they provide their own &quot;bridging&quot;</li></ul></section>

      </article>
    </div>
    
    <div id="mask"></div>
  </main>

  <div class="floating_action_container">
    <a id="floating_action" class="ripple" href="#">
      <i class="mdi-action-explore"></i>
    </a>
    <div id="floating_action_menu">
      <span class="bubble"></span>
      <ul class="list-group content">
        <li class="list-group-item ripple"><a>Cras justo odio</a></li>
        <li class="list-group-item ripple"><a>Dapibus ac facilisis in</a></li>
        <li class="list-group-item ripple"><a>Morbi leo risus</a></li>
        <li class="list-group-item ripple"><a>Porta ac consectetur ac</a></li>
        <li class="list-group-item ripple"><a>Vestibulum at eros</a></li>
      </ul>
    </div>
  </div>
  </body>
</html>